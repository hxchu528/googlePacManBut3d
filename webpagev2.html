<!DOCTYPE html>
<html>
<style>
body{
overflow-y:hidden;
overflow-x:hidden;
}
#renderCanvas{
	width:100vw;
	height:100vh;
}
</style>
<body>
<canvas id="renderCanvas"></canvas>
</body>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
var keys = [];
window.addEventListener("keydown",()=>{keys[event.key] = true})
window.addEventListener("keyup",()=>{keys[event.key] = false})
const canvas = document.getElementById('renderCanvas');
const engine = new BABYLON.Engine(canvas, true);
var size = 3;
var camP = [];
var point = [];
function expand(str) {
	let expandedStr = '';
	let i = 0;
	while (i < str.length) {
		let num = '';
		while (!isNaN(str[i])) {
			num += str[i];
			i++;
		}
		let char = str[i];
		expandedStr += char.repeat(parseInt(num));
		i++;
	}
    return expandedStr;
}
function scale(n,or1,or2,r1,r2){return r1+(r2-r1)*((n-or1)/(or2-or1));}
function map(scene){
	var bmp = ["58a","1a56b1a","1a1b3a1b9a1b15a1b8a1c3a1b5a1b5a1b1a","1a1b3a1b9a1b15a1b8a1c3a1b5a1b5a1b1a","1a5b9a17b9c3a13b1a","5a1b3a7b7a1b7a1c3a2d3a1c3a1b7a1b5a","5a1b3a1b5a1b7a1b7a1c1a6c1a1c3a1b7a1b5a","5a1b3a1b5a1b7a1b7a1c1a6c1a1c3a1b7a1b5a","5c1b3a3b3a1b7a1b7a1c1a6c1a1c3a1b7a1b5c","5a1b9a1b7a1b7a1c8a1c3a1b3a5b5a","5a1b9a1b7a1b7a1c8a1c3a1b7a1b5a","5a1b9a1b7a1b7a10c3a1b7a1b5a","1a31b8a17b1a","1a1b4a1b10a1b2a1b10a4b2a4b9a1b5a1b1a","1a1b4a1b10a1b2a1b10a1b2a1b2a1b2a1b9a1b5a1b1a","1a17b2a12b2a1b2c1b2a17b1a","58a"];
	for(var i = 0; i<bmp.length/2; i++){
		var temp = bmp[i];
		bmp[i] = bmp[bmp.length-1-i];
		bmp[bmp.length-1-i] = temp;
	}
	var wall = [];
	for(var i = 0; i<bmp.length; i++){
		bmp[i] = expand(bmp[i])
		for(var j = 0; j<bmp[i].length; j++){
			if(bmp[i][j]==="a"){
				wall.push(new BABYLON.MeshBuilder.CreateBox("box",{width:1*size,depth:1*size,height:1*size},scene))
				wall[wall.length-1].position = new BABYLON.Vector3((j-36)*size,0.5*size,(i-1)*size)
				var mat = new BABYLON.StandardMaterial("mat",scene);
				mat.diffuseColor = new BABYLON.Color3(0,1,0);
				wall[wall.length-1].material = mat;
			}else if(bmp[i][j]==="d"){
				wall.push(new BABYLON.MeshBuilder.CreateBox("box",{width:1*size,depth:1*size,height:1*size},scene))
				wall[wall.length-1].position = new BABYLON.Vector3((j-36)*size,0.5*size,(i-1)*size)
				var mat = new BABYLON.StandardMaterial("mat",scene);
				mat.diffuseColor = new BABYLON.Color3(1,1,0);
				wall[wall.length-1].material = mat;
			}
		}
	}
	//shift position
	for(var i = -35; i<=20; i++){
		for(var j = 0; j<=15; j++){
			if(bmp[j+1][i+36]!="a" && bmp[j+1][i+36]!="c" && bmp[j+1][i+36]!="d"){
				if((j===12 && i===-35)||(j===0 && i===-35)||(j===7&&i===-25)||(j===12&&i===20)||(j===0&&i===20)){
				point.push({pos:[i*size,j*size],type:2});
				}else{
				point.push({pos:[i*size,j*size],type:1});
				}
			}
		}
	}
	var a = BABYLON.Mesh.MergeMeshes(wall, true, false, null, false, true);
	return a;
}
function ray (origin, direction, scene) {
	const dir = new BABYLON.Vector3(Math.cos(direction),0,Math.sin(direction));
	const ray = new BABYLON.Ray(origin, dir, 100);
	const hit = scene.pickWithRay(ray);
	if (hit.hit) {
		return BABYLON.Vector3.Distance(origin, hit.pickedPoint);
	}
	return undefined;
};
function ghost(scene,color = "red"){
	const cylinder = BABYLON.MeshBuilder.CreateCylinder("cylinder", { height: size/2, diameterTop: 0.4*size, diameterBottom: 0.4*size, tessellation: 24 }, scene);
	const sphere = BABYLON.MeshBuilder.CreateSphere("sphere",{diameter:0.4*size},scene);
	cylinder.position = new BABYLON.Vector3(0,size/4,0);
	sphere.position = new BABYLON.Vector3(0,size/2,0);
	var spmat = new BABYLON.StandardMaterial('combinedMaterial', scene);
	spmat.diffuseColor = color==="red"?new BABYLON.Color3(1, 0, 0):color==="pink"?new BABYLON.Color3(1, 0.75, 1):new BABYLON.Color3(0,1,1);
	sphere.material = spmat;
	var cymat = new BABYLON.StandardMaterial('combinedMaterial', scene);
	const texture = new BABYLON.DynamicTexture("texture",{width:200,height:100},scene);
	cymat.diffuseTexture = texture;
	cylinder.material = cymat;
	const ctx = texture.getContext();
	ctx.fillStyle = color==="red"?"rgb(255,0,0)":color==="pink"?"rgb(255,191,255)":"rgb(0,255,255)";
	ctx.fillRect(0,0,200,100);
	ctx.fillStyle = "white";
	ctx.beginPath();
		ctx.arc(185,30,7,0,2*Math.PI);
	ctx.stroke();
	ctx.fill();
	ctx.beginPath();
		ctx.arc(15,30,7,0,2*Math.PI);
	ctx.stroke();
	ctx.fill();
	ctx.fillStyle = "black";
	ctx.beginPath();
		ctx.arc(185,30,3,0,2*Math.PI);
	ctx.stroke();
	ctx.fill();
	ctx.beginPath();
		ctx.arc(15,30,3,0,2*Math.PI);
	ctx.stroke();
	ctx.fill();
	texture.update();
	var a = BABYLON.Mesh.MergeMeshes([cylinder,sphere], true, false, null, false, true);
	return a;
}
function red(g,p,m,d){
	var ray = [new BABYLON.Ray(g.position,new BABYLON.Vector3(1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,1),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(-1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,-1),size)];
    
	var poss = [0,0,0,0];
	for(var i = 0; i<ray.length; i++){
		if(!m.intersects(ray[i]).hit){poss[i] = 1;}
	}
	if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){d += 1;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){d +=3;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(p.position.z-g.position.z,p.position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:1;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		var ang =  Math.atan2(p.position.z-g.position.z,p.position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===1?1:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(p.position.z-g.position.z,p.position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(p.position.z-g.position.z,p.position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===0?0:ang===1?1:3;
	}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		d += 2;
	}
	if(d>=4){d = d%4;}
	return d;
}
function pink(g,p,m,d){
	var ray = [new BABYLON.Ray(g.position,new BABYLON.Vector3(1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,1),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(-1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,-1),size)];
    
	var poss = [0,0,0,0];
	for(var i = 0; i<ray.length; i++){
		if(!m.intersects(ray[i]).hit){poss[i] = 1;}
	}
	var rot = Math.round(scale((p.rotation.y + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
	rot += 1;
	rot = rot<0?4+rot:rot%4;
	var position = {x:Math.round(scale(p.position.x,-36*size,21*size,-36,21))*size-Math.cos(rot*Math.PI/2)*size*4,z:Math.round(scale(p.position.z,-1*size,16*size,-1,16))*size+Math.sin(rot*Math.PI/2)*size*4};
	if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){d += 1;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){d +=3;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:1;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		var ang =  Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===1?1:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===1?1:ang===0?0:3;
	}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		d += 2;
	}
	if(d>=4){d = d%4;}
	return d;
}
function pink(g,p,m,d){
	var ray = [new BABYLON.Ray(g.position,new BABYLON.Vector3(1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,1),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(-1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,-1),size)];
    
	var poss = [0,0,0,0];
	for(var i = 0; i<ray.length; i++){
		if(!m.intersects(ray[i]).hit){poss[i] = 1;}
	}
	var rot = Math.round(scale((p.rotation.y + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
	rot += 1;
	rot = rot<0?4+rot:rot%4;
	var position = {x:Math.round(scale(p.position.x,-36*size,21*size,-36,21))*size-Math.cos(rot*Math.PI/2)*size*4,z:Math.round(scale(p.position.z,-1*size,16*size,-1,16))*size+Math.sin(rot*Math.PI/2)*size*4};
	if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){d += 1;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){d +=3;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:1;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		var ang =  Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===1?1:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===1?1:ang===0?0:3;
	}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		d += 2;
	}
	if(d>=4){d = d%4;}
	return d;
}
function blue(g,r,p,m,d){
	var ray = [new BABYLON.Ray(g.position,new BABYLON.Vector3(1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,1),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(-1,0,0),size),new BABYLON.Ray(g.position,new BABYLON.Vector3(0,0,-1),size)];
    
	var poss = [0,0,0,0];
	for(var i = 0; i<ray.length; i++){
		if(!m.intersects(ray[i]).hit){poss[i] = 1;}
	}
	var rot = Math.round(scale((p.rotation.y + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
	rot += 1;
	rot = rot<0?4+rot:rot%4;
	var position = {x:Math.round(scale(p.position.x,-36*size,21*size,-36,21))*size-Math.cos(rot*Math.PI/2)*size*2,z:Math.round(scale(p.position.z,-1*size,16*size,-1,16))*size+Math.sin(rot*Math.PI/2)*size*2};
	position.x += Math.round((position.x-r.position.x)/size)*size;
	position.z += Math.round((position.z-r.position.z)/size)*size;
	if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){d += 1;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){d +=3;}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:1;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		var ang =  Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===1?1:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===3?3:0;
	}
	else if(poss[d%poss.length]!=0 && poss[(d+1)%poss.length]!=0 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=0){
		var ang = Math.atan2(position.z-g.position.z,position.x-g.position.x)-Math.PI/2*d;
		ang = Math.round(scale((ang + 2 * Math.PI) % (2 * Math.PI),0,2*Math.PI,0,4))%4;
		ang = ang<0?4+ang:ang;
		d += ang===1?1:ang===0?0:3;
	}
	else if(poss[d%poss.length]!=1 && poss[(d+1)%poss.length]!=1 && poss[(d+2)%poss.length]!=0 && poss[(d+3)%poss.length]!=1){
		d += 2;
	}
	if(d>=4){d = d%4;}
	return d;
}
// Function to create the scene
function createScene(){
    // Create a basic Babylon Scene object
    const scene = new BABYLON.Scene(engine);
    // Create a camera and position it at (0, 5, -10)
    const camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 0.5, 0), scene);
	camera.speed = 0.2;
    // Attach the camera to the canvas to enable user input
    camera.attachControl(canvas, true);
	var cam2 = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(-7*size, 60*size, 19/2*size), scene);
	cam2.setTarget(BABYLON.Vector3.Zero());
	cam2.rotation = new BABYLON.Vector3(Math.PI/2,0,0);
    const bklight = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
	bklight.intensity = 0.4;
	const light = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(0, -1, 0), scene);
    light.intensity = 0.7;
	var m = map(scene);
	camera.checkCollisions = true;
	camera.ellipsoid = new BABYLON.Vector3(0.5, 0.5, 0.5);
	camera.minZ = 0;
	m.checkCollisions = true;
	m.material.backFaceCulling = true;
	var showPoint = [];
	for(var i = 0; i<point.length; i++){
		showPoint.push(BABYLON.MeshBuilder.CreateSphere("n",{diameter:point[i].type===1?0.25:0.5},scene));
		showPoint[showPoint.length-1].position = new BABYLON.Vector3(point[i].pos[0],0.5,point[i].pos[1]);
		showPoint[showPoint.length-1].checkCollisions = false;
		var mat = new BABYLON.StandardMaterial('mat', scene);
		mat.diffuseColor = new BABYLON.Color3(1, 1, 0);
		showPoint[showPoint.length-1].material = mat;
	}
	var g = [ghost(scene,"red"),ghost(scene,"pink"),ghost(scene,"blue")];
	g[0].position = new BABYLON.Vector3(-1*size,0.1,11*size);
	g[1].position = new BABYLON.Vector3(1*size,0.1,11*size);
	g[2].position = new BABYLON.Vector3(0*size,0.1,11*size);
	var gd = [0,2,2];
	var gp = [];
	for(var i = 0; i<g.length; i++){
	gp.push([g[i].position.x+Math.cos(gd[i]*Math.PI/2)*size,g[i].position.z+Math.sin(gd[i]*Math.PI/2)*size])
	}
    const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 58*size, height: 17*size }, scene);
	const material = new BABYLON.StandardMaterial('mat', scene);
	material.diffuseColor = new BABYLON.Color3(1, 1, 1);
	ground.material = material;
	ground.position.z = 7*size;
	ground.position.x = -7.5*size;
	scene.registerBeforeRender(function(){
		for(var i = 0; i<g.length; i+=1){
		if((gp[i][0]-g[i].position.x)**2+(gp[i][1]-g[i].position.z)**2<0.5){
			g[i].position.x = gp[i][0];
			g[i].position.z = gp[i][1];
			gd[i] = i===0?red(g[i],camera,m,gd[i]):i===1?pink(g[i],camera,m,gd[i]):blue(g[i],g[0],camera,m,gd[i]);
			gp[i] = [g[i].position.x+Math.cos(gd[i]*Math.PI/2)*size,g[i].position.z+Math.sin(gd[i]*Math.PI/2)*size]
		}
		g[i].rotation = new BABYLON.Vector3(0,gd[i]*Math.PI/2,0);
		if(g[i].position.x<-36*size){g[i].position.x = 21*size;gd[i] = pink(g[i],camera,m,gd[i]);
			gp[i] = [g[i].position.x+Math.cos(gd[i]*Math.PI/2)*size,g[i].position.z+Math.sin(gd[i]*Math.PI/2)*size]
		}
		if(g[i].position.x>21*size){
			g[i].position.x = -36*size;
			gd[i] = i===0?red(g[i],camera,m,gd[i]):i===1?pink(g[i],camera,m,gd[i]):blue(g[i],g[0],camera,m,gd[i]);
			gp[i] = [g[i].position.x+Math.cos(gd[i]*Math.PI/2)*size,g[i].position.z+Math.sin(gd[i]*Math.PI/2)*size]
		}
			g[i].position.x+=Math.cos(gd[i]*Math.PI/2)*0.1;
			g[i].position.z+=Math.sin(gd[i]*Math.PI/2)*0.1;
		}
		scene.activeCamera = camera;
		camera.position.y = 0.6;
		const forwardRay = camera.getForwardRay();
		light.direction = forwardRay.direction;
		light.intensity = 0.7;
		for(var i = 0; i<showPoint.length; i++){
			if(BABYLON.Vector3.Distance(camera.position, showPoint[i].position)<size){
				showPoint[i].dispose();
			}
		}
		if(camera.position.x<-36*size){camera.position.x = 21*size;}
		if(camera.position.x>21*size){camera.position.x = -36*size;}
		if(keys["a"]){camera.rotation.y-=3*Math.PI/180;}
		if(keys["d"]){camera.rotation.y+=3*Math.PI/180;}
		if(keys["e"]){
			scene.activeCamera = cam2;
			light.intensity = 0;
		}
	})
    return scene;
};

// Call the createScene function
const scene = createScene();

// Start the BabylonJS rendering loop
engine.runRenderLoop(() => {
    scene.render();
});

// Resize the engine when the window is resized
window.addEventListener('resize', () => {
    engine.resize();
});

</script>
</html>
