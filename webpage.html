
<!DOCTYPE html>
<html>
<style>
body{
overflow-y:hidden;
overflow-x:hidden;
}
#renderCanvas{
	width:100vw;
	height:100vh;
}
</style>
<body>
<canvas id="renderCanvas"></canvas>
</body>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script>
var keys = [];
window.addEventListener("keydown",()=>{keys[event.key] = true})
window.addEventListener("keyup",()=>{keys[event.key] = false})
// Create the Babylon.js engine and attach it to the canvas element
const canvas = document.getElementById('renderCanvas'); // Make sure there is a canvas element with this ID in your HTML
const engine = new BABYLON.Engine(canvas, true);
var size = 1.5;
function expand(str) {
	let expandedStr = '';
	let i = 0;
	while (i < str.length) {
		let num = '';
		while (!isNaN(str[i])) {
			num += str[i];
			i++;
		}
		let char = str[i];
		expandedStr += char.repeat(parseInt(num));
		i++;
	}
    return expandedStr;
}
var point = [];
function map(scene){
	var bmp = ["58a","1a56b1a","1a1b3a1b9a1b15a1b8a1c3a1b5a1b5a1b1a","1a1b3a1b9a1b15a1b8a1c3a1b5a1b5a1b1a","1a5b9a17b9c3a13b1a","5a1b3a7b7a1b7a1c3a2c3a1c3a1b7a1b5a","5a1b3a1b5a1b7a1b7a1c1a6c1a1c3a1b7a1b5a","5a1b3a1b5a1b7a1b7a1c1a6c1a1c3a1b7a1b5a","5c1b3a3b3a1b7a1b7a1c1a6c1a1c3a1b7a1b5c","5a1b9a1b7a1b7a1c8a1c3a1b3a5b5a","5a1b9a1b7a1b7a10c3a1b7a1b5a","5a1b9a1b7a1b7a10c3a1b7a1b5a","1a31b8a17b1a","1a1b4a1b10a1b2a1b10a4b2a4b9a1b5a1b1a","1a1b4a1b10a1b2a1b10a1b2a1b2a1b2a1b9a1b5a1b1a","1a17b2a12b2a1b2c1b2a17b1a","58a"];
	for(var i = 0; i<bmp.length/2; i++){
		var temp = bmp[i];
		bmp[i] = bmp[bmp.length-1-i];
		bmp[bmp.length-1-i] = temp;
	}
	var wall = [];
	for(var i = 0; i<bmp.length; i++){
		bmp[i] = expand(bmp[i])
		for(var j = 0; j<bmp[i].length; j++){
			if(bmp[i][j]==="a"){
				wall.push(new BABYLON.MeshBuilder.CreateBox("box",{width:1*size,depth:1*size,height:1*size},scene))
				wall[wall.length-1].position = new BABYLON.Vector3((j-36)*size,0.5*size,(i-1)*size)
			}
		}
	}
	for(var i = -35; i<=20; i++){
		for(var j = 0; j<=15; j++){
			if(bmp[j+1][i+36]!="a" && bmp[j+1][i+36]!="c"){
				if((j===12 && i===-35)||(j===0 && i===-35)||(j===7&&i===-25)||(j===12&&i===20)||(j===0&&i===20)){
				point.push({pos:[i*size,j*size],type:2});
				}else{
				point.push({pos:[i*size,j*size],type:1});
				}
			}
		}
	}
	var a = BABYLON.Mesh.MergeMeshes(wall, true, false, null, false, true);
	const combinedMaterial = new BABYLON.StandardMaterial('combinedMaterial', scene);
    combinedMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green color
    a.material = combinedMaterial;
	return a;
}
// Function to create the scene
function createScene(){
    // Create a basic Babylon Scene object
    const scene = new BABYLON.Scene(engine);

    // Create a camera and position it at (0, 5, -10)
    const camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 0.5, 0), scene);
	camera.speed = 0.2;
    // Attach the camera to the canvas to enable user input
    camera.attachControl(canvas, true);

    // Create a basic light, aiming at the center of the scene
    const bklight = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
	bklight.intensity = 0.4;
	const light = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(0, -1, 0), scene);
    light.intensity = 0.7;
	var m = map(scene);
	camera.checkCollisions = true;
	camera.ellipsoid = new BABYLON.Vector3(0.5, 0.5, 0.5); // Camera collision ellipsoid
	camera.minZ = 0;
	m.checkCollisions = true; // Enable collision on the mesh
	m.material.backFaceCulling = true; // Enable backface culling
	var showPoint = [];
	for(var i = 0; i<point.length; i++){
		showPoint.push(BABYLON.MeshBuilder.CreateBox("n",{size:point[i].type===1?0.1:0.5},scene));
		showPoint[showPoint.length-1].position = new BABYLON.Vector3(point[i].pos[0],0.5,point[i].pos[1]);
		showPoint[showPoint.length-1].checkCollisions = false;
	}

    // Create a built-in "ground" shape and place it beneath the sphere
    const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 58*size, height: 17*size }, scene);
	ground.position.z = 7*size;
	ground.position.x = -7.5*size;
	scene.registerBeforeRender(function(){
		camera.position.y = 0.6;
		const forwardRay = camera.getForwardRay();
		light.direction = forwardRay.direction;
		for(var i = 0; i<showPoint.length; i++){
			if(BABYLON.Vector3.Distance(camera.position, showPoint[i].position)<size){
				showPoint[i].dispose();
			}
		}
		if(keys["a"]){camera.rotation.y-=3*Math.PI/180;}
		if(keys["d"]){camera.rotation.y+=3*Math.PI/180;}
	})
    return scene;
};

// Call the createScene function
const scene = createScene();

// Start the BabylonJS rendering loop
engine.runRenderLoop(() => {
    scene.render();
});

// Resize the engine when the window is resized
window.addEventListener('resize', () => {
    engine.resize();
});

</script>
</html>
